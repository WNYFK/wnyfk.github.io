<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>陈斌的记事本</title><description>陈斌 Publish Blogs</description><link>https://your-website-url.com</link><language>zh</language><lastBuildDate>Tue, 14 Dec 2021 18:58:15 +0800</lastBuildDate><pubDate>Tue, 14 Dec 2021 18:58:15 +0800</pubDate><ttl>250</ttl><atom:link href="https://your-website-url.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://your-website-url.com/posts/remind</guid><title>remind</title><description></description><link>https://your-website-url.com/posts/remind</link><pubDate>Tue, 14 Dec 2021 18:58:09 +0800</pubDate><content:encoded><![CDATA[<h4>没怎么写过，那下一步怎么行动</h4><p>看到这里，你一定会想“看你说了那么多，但我双手放在键盘前，脑袋还是一片空白，无从下手”。</p><p>如果想帮其他人，让他真的动手去做些什么事情，其实更应该是要让做这件事情变得容易很多倍，但方向是一样的，这样下次他就更好接受些。互联网开始发布内容门槛高，后来有了微博和朋友圈这种能够一句话就快速发布出去的产品后，大家发内容就比以前更多了。去读资料和文章，可以懂更多的知识，自身能力还是需要通过练习才能够有提升。想把事情做好，还是需要去做。</p><p>因此你应该更重视动手写，如果你不知道如何写，可能就不知道如何思考。有叛逆和逆向思维的人常常是爱问问题的人，爱自问爱思考，对那些已经共识正在运作的事物提出疑问，寻找和关注答案，这样才会有打破现状的意识。一些人小时候就能看到有这样的特点，因此在别人教你怎样怎样做时，不要太当回事，相信自己实践出来的答案。多听你喜欢人说话，多倾听，不断问还有没想说的。</p><p>还要从各种类型人那学习，甚至是和你观点不同的人。因为在每个人坚持的思想里，都会有他自己独特的经历和实践总结来的结论。通过他们的结论，你也可以自己去实践和验证形成自己的观点，这样就会有复利效应。做的结果其实并不重要，重要的是在做的过程中，你自己有没有变得更好。</p><p>你说的话，你的观点，你的评论都不能代表你，而是你所做的事情，花了很多时间做的事情那才是你。改变一个人的行为来改变思维，比改变一个人的思维来改变行为要容易的多很多。</p><p>因此，光看光听不动手写是没用的。那行动起来的话，怎么做更好些呢？</p><h5>四个步骤</h5><h6>第一步</h6><p>零散的想法、工作内容和看到的好的技术资料及时记录，先按照时间轴的方式记录。这一步是很容易操作的，几乎不用费脑，只需要机械的做记录就行，也不用考虑先前提到四个点里任何一个。</p><h6>第二步</h6><p>对于记录的内容进行分类，开始粒度可以粗一点，比如性能、架构、构建、编程语言、管理、成长、旅行和科技等，根据自身兴趣点和期望发展方向来就好。</p><h6>第三步</h6><p>做完一个项目，或者想对先前做的事情进行总结时，先一口气快速写出想表达的内容出来，这时写的内容体现出独特性，搭好骨架。然后针对写的内容中的一些技术点，进行真实感的完善。真实感的完善是需要很多素材和资料的，这时在第一步和第二步做的工作和积累就能够派上用场了。找到相关大分类进行细分来补充文章的血肉。</p><h6>第四步</h6><p>也是最后一步，可以充分发挥自己软实力和创造力，通过故事性和新意来披上文章的皮肤，让文章能够看起来更加完整和吸引人，提高阅读的体验。</p><p>完整完成这四个步骤并不容易，经常就会因为惰性半途而废。这时就需要 push 自己一把，方法的话，我这边的经验就是定目标，定时间节点。比如定好一个对外分享的时间，这样目标性更强，同时也有了约束和责任，自己的惰性在这一段时间内就能够得到很好的消减。</p><p>为了达成目的，彻底理清你想要啥，还需要清空干扰，方法很简单，除了当前最重要的事情，其它所有待做事情都记在备忘录里以便追踪防止遗漏。完成当前事情后，再去查看备忘录，然后定新目标新计划。</p><h5>完成文章后可以通过下面八个问题来检查下文章的完成度。</h5><ul><li>我为什么做这件事？</li><li>谁已经做了？他们都是怎么做的？效果怎样？</li><li>我和他们做的不一样在哪？怎么想到的？能详细具体说出涉及相关知识点吗？（⭐️重点，写好了的话，其他问题可有可无）</li><li>我碰到了什么困难？</li><li>我怎么解决的？</li><li>做的有亮点吗？为什么是亮点？</li><li>做完后效果是怎样的？超预期地方在哪？</li><li>以后还有计划打算吗？为什么？</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/rx_Share_replay_shareReplay</guid><title>rx_Share_replay_shareReplay</title><description></description><link>https://your-website-url.com/posts/rx_Share_replay_shareReplay</link><pubDate>Tue, 14 Dec 2021 18:45:22 +0800</pubDate><content:encoded><![CDATA[<h3>RxSwift学习记录- share vs replay vs shareReplay</h3><h4>问题描述</h4><img src="https://github.com/WNYFK/wnyfk.github.io/blob/master/images/icon.png?raw=true" alt="图片"/><p>多个订阅者导致Observable重复执行</p><pre data-language="undefined"><code>
let results: Observable<String> = Observable<Int>.interval(.seconds(1), scheduler: MainScheduler.instance)
    .map { "\($0)" }
    .flatMapLatest(convert)
    
func convert(str: String) -> Observable<String> {
    Observable<String>.create { observer in
        print("convert啊啊啊啊啊啊")
        observer.onNext("\(str)===convert")
        observer.onCompleted()
        return Disposables.create()
    }
}
</code></pre><p>下面三个订阅会使Observable创建三次，原本希望的是三个订阅者订阅同一次</p><pre data-language="undefined"><code>
let results = results.share()
results.subscribe(onNext: { str in
    print("第一个订阅者:\(str)")
}).disposed(by: disposeBag)
results.subscribe(onNext: { str in
    print("第二个订阅者:\(str)")
}).disposed(by: disposeBag)
results.subscribe(onNext: { str in
    print("第三个订阅者:\(str)")
}).disposed(by: self.disposeBag)

</code></pre><h4>share</h4><p>所有订阅者订阅后共用同一个Observable</p><pre data-language="undefined"><code>
let results = results.share()
results.subscribe(onNext: { str in
    print("第一个订阅者:\(str)")
}).disposed(by: disposeBag)
results.subscribe(onNext: { str in
    print("第二个订阅者:\(str)")
}).disposed(by: disposeBag)
delay(4) { 
    results.subscribe(onNext: { str in
        print("第三个订阅者:\(str)")
    }).disposed(by: self.disposeBag)
}
</code></pre><p>结果</p><pre data-language="undefined"><code>
convert啊啊啊啊啊啊
第一个订阅者:2===convert
第二个订阅者:2===convert
convert啊啊啊啊啊啊
第一个订阅者:3===convert
第二个订阅者:3===convert
convert啊啊啊啊啊啊
第一个订阅者:4===convert
第二个订阅者:4===convert
第三个订阅者:4===convert
</code></pre><h4>publish</h4><p>需手动<code>connect</code>，<code>connect</code>后开始发射值</p><pre data-language="undefined"><code>
let results = results.publish()
results.subscribe(onNext: { str in
    print("第一个订阅者:\(str)")
}).disposed(by: disposeBag)
results.subscribe(onNext: { str in
    print("第二个订阅者:\(str)")
}).disposed(by: disposeBag)
_ = results.connect()
delay(4) { 
    results.subscribe(onNext: { str in
        print("第三个订阅者:\(str)")
    }).disposed(by: self.disposeBag)
}
</code></pre><h4>replayAll</h4><p>后面订阅者会订阅后会收到所有之前的信号</p><h4>shareReplay</h4><p>共享Observable，且第一次订阅会重复播放对应数目信号</p><pre data-language="undefined"><code>
let results = results.share(replay: 2, scope: .forever)
results.subscribe(onNext: { str in
    print("第一个订阅者:\(str)")
}).disposed(by: disposeBag)
results.subscribe(onNext: { str in
    print("第二个订阅者:\(str)")
}).disposed(by: disposeBag)
delay(4) { 
    results.subscribe(onNext: { str in
        print("第三个订阅者:\(str)")
    }).disposed(by: self.disposeBag)
}
</code></pre><p>结果</p><pre data-language="undefined"><code>
convert啊啊啊啊啊啊
第一个订阅者:2===convert
第二个订阅者:2===convert
convert啊啊啊啊啊啊
第一个订阅者:3===convert
第二个订阅者:3===convert
第三个订阅者:2===convert
第三个订阅者:3===convert

</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/Rx_Operator</guid><title>Rx_Operator</title><description></description><link>https://your-website-url.com/posts/Rx_Operator</link><pubDate>Tue, 14 Dec 2021 18:44:28 +0800</pubDate><content:encoded><![CDATA[]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/reactorkit</guid><title>reactorkit</title><description></description><link>https://your-website-url.com/posts/reactorkit</link><pubDate>Mon, 13 Dec 2021 18:54:22 +0800</pubDate><content:encoded><![CDATA[<h3>flux相关</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/20263396">flux原理图解</a></li><li><a href="https://www.jianshu.com/p/87c32a0fce28">flux详细概述</a></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/ios_blogs</guid><title>iOS博客列表</title><description>iOS的博客.</description><link>https://your-website-url.com/posts/ios_blogs</link><pubDate>Wed, 1 Dec 2021 11:47:00 +0800</pubDate><content:encoded><![CDATA[<h2>周报</h2><ul><li><a href="https://github.com/SwiftOldDriver/iOS-Weekly/releases">老司机iOS周报</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjU2Mzc1MQ==&mid=2247486791&idx=1&sn=2695a508ea45e43527875058ad106e6d&chksm=cf55828ff8220b990eb722b4fb149b8cd424133d05646ea7e369ab4597c1e97503714a6f20dd&token=1722840270&lang=zh_CN#rd">DNS 服务器</a></li></ul><h2>原理</h2><ul><li><a href="https://juejin.cn/post/7015861914370736136">iOS编码对包大小的影响</a></li><li><a href="https://mp.weixin.qq.com/s/MIun-eV4_J1hXGDRjGoLaw">百度符号化</a></li><li><a href="https://mp.weixin.qq.com/s/TVRYXhiOXIsMmXZo9GmEVA">字节符号化</a></li><li><a href="https://kemchenj.github.io/2020-10-02/">swift atomic</a></li><li><a href="https://www.emergetools.com/blog/posts/iOS15LaunchTime">iOS15 launchTime</a></li><li><a href="https://mp.weixin.qq.com/s/ElGEsJoh3Y1-BWlvz1yJ9w">UIView &amp; CALayer</a></li></ul><h2>三方库</h2><ul><li><a href="https://juejin.cn/post/6885605205380562952">YYCache</a></li><li></li></ul><h2>新特性</h2><ul><li><a href="https://emptytheory.com/2021/08/14/creating-custom-parseable-format-styles-in-ios-15/">iOS15 format</a></li><li><a href="https://mp.weixin.qq.com/s/DopuYyy479eSjgns3iaWaw">Async and Await in Swift 5.5</a></li><li><a href="https://xiaozhuanlan.com/wwdc21">WWDC21内参</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/markdown%E8%AF%AD%E6%B3%95</guid><title>Markdown 语法和 MWeb 写作使用说明</title><description></description><link>https://your-website-url.com/posts/markdown%E8%AF%AD%E6%B3%95</link><pubDate>Wed, 1 Dec 2021 11:43:11 +0800</pubDate><content:encoded><![CDATA[<h1>Markdown 语法和 MWeb 写作使用说明</h1><h2>Markdown 的设计哲学</h2><blockquote><p>Markdown 的目標是實現「易讀易寫」。 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。 Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。<!-- more --></p></blockquote><h2>本文约定</h2><p>如果有写 <code>效果如下：</code>， 在 MWeb 编辑状态下只有用 <code>CMD + 4</code> 或 <code>CMD + R</code> 预览才可以看效果。</p><h2>标题</h2><p>Markdown 语法：</p><pre data-language="undefined"><code>
# 第一级标题 `<h1>` 
## 第二级标题 `<h2>` 
###### 第六级标题 `<h6>` 
</code></pre><p>效果如下：</p><h1>第一级标题 <code>&lt;h1&gt;</code></h1><h2>第二级标题 <code>&lt;h2&gt;</code></h2><h6>第六级标题 <code>&lt;h6&gt;</code></h6><h2>强调</h2><p>Markdown 语法：</p><pre data-language="undefined"><code>
*这些文字会生成`<em>`*
_这些文字会生成`<u>`_

**这些文字会生成`<strong>`**
__这些文字会生成`<strong>`__
</code></pre><p>在 MWeb 中的快捷键为： <code>CMD + U</code>、<code>CMD + I</code>、<code>CMD + B</code> 效果如下：</p><p><em>这些文字会生成<code>&lt;em&gt;</code></em> <em>这些文字会生成<code>&lt;u&gt;</code></em></p><p><strong>这些文字会生成<code>&lt;strong&gt;</code></strong> <strong>这些文字会生成<code>&lt;strong&gt;</code></strong></p><h2>换行</h2><p>四个及以上空格加回车。 如果不想打这么多空格，只要回车就为换行，请勾选：<code>Preferences</code> - <code>Themes</code> - <code>Translate newlines to &lt;br&gt; tags</code></p><h2>列表</h2><h3>无序列表</h3><p>Markdown 语法：</p><pre data-language="undefined"><code>
* 项目一 无序列表 `* + 空格键`
* 项目二
	* 项目二的子项目一 无序列表 `TAB + * + 空格键`
	* 项目二的子项目二
</code></pre><p>在 MWeb 中的快捷键为： <code>Option + U</code> 效果如下：</p><ul><li>项目一 无序列表 <code>* + 空格键</code></li><li>项目二<ul><li>项目二的子项目一 无序列表 <code>TAB + * + 空格键</code></li><li>项目二的子项目二</li></ul></li></ul><h3>有序列表</h3><p>Markdown 语法：</p><pre data-language="undefined"><code>
1. 项目一 有序列表 `数字 + . + 空格键`
2. 项目二 
3. 项目三
	1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`
	2. 项目三的子项目二
</code></pre><p>效果如下：</p><ol><li>项目一 有序列表 <code>数字 + . + 空格键</code></li><li>项目二</li><li>项目三<ol><li>项目三的子项目一 有序列表 <code>TAB + 数字 + . + 空格键</code></li><li>项目三的子项目二</li></ol></li></ol><h3>列表中嵌入代码块语法</h3><ol><li>项目一 有序列表 <code>数字 + . + 空格键</code><ul></ul></li></ol><p>列表中嵌入代码块必须前后空一行，如这个写法<br> <code></code>`js function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) } } <code></code>`<br> 其他文本。<br> 2. 项目二</p><h3>任务列表（Task lists）</h3><p>Markdown 语法：</p><pre data-language="undefined"><code>
- [ ] 任务一 未做任务 `- + 空格 + [ ]`
- [x] 任务二 已做任务 `- + 空格 + [x]`
</code></pre><p>效果如下：</p><ul><li>[ ] 任务一 未做任务 <code>- + 空格 + [ ]</code></li><li>[x] 任务二 已做任务 <code>- + 空格 + [x]</code></li></ul><h2>图片</h2><p>Markdown 语法：</p><pre data-language="undefined"><code>
![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)
格式: ![Alt Text](url)
</code></pre><p><code>Control + Shift + I</code> 可插入Markdown语法。 如果是 MWeb 的文档库中的文档，还可以用拖放图片、<code>CMD + V</code> 粘贴、<code>CMD + Option + I</code> 导入这三种方式来增加图片。 效果如下：</p><img src="http://zh.mweb.im/asset/img/set-up-git.gif" alt="GitHub set up"/><p>MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 <code>-w + 图片宽度</code> 即可，比如说要设置上面的图片的宽度为 140，语法如为 <code>![GitHub-w140](set-up-git.gif)</code>：</p><img src="http://zh.mweb.im/asset/img/set-up-git.gif" alt="GitHub set up-w140"/><h2>链接</h2><p>Markdown 语法：</p><pre data-language="undefined"><code>
email <example@example.com>
[GitHub](http://github.com)
自动生成连接  <http://www.github.com/>
</code></pre><p><code>Control + Shift + L</code> 可插入Markdown语法。 如果是 MWeb 的文档库中的文档，拖放或<code>CMD + Option + I</code> 导入非图片时，会生成连接。 效果如下：</p><p>Email 连接： <example@example.com>
[连接标题Github网站](http://github.com)
自动生成连接像： <http://www.github.com/> 这样

## 区块引用

Markdown 语法：

```
某某说:
> 第一行引用
> 第二行费用文字
```

`CMD + Shift + B` 可插入Markdown语法。
效果如下：

某某说:
> 第一行引用
> 第二行费用文字

## 行内代码

Markdown 语法：

```
像这样即可：`<addr>` `code`
```

`CMD + K` 可插入Markdown语法。
效果如下：

像这样即可：`<addr>` `code`

## 多行或者一段代码

Markdown 语法：

	```js
	function fancyAlert(arg) {
	  if(arg) {
	    $.facebox({div:'#foo'})
	  }

	}
	```

`CMD + Shift + K` 可插入Markdown语法。
效果如下：

```js
function fancyAlert(arg) {
	if(arg) {
		$.facebox({div:'#foo'})
	}

}
```

## 顺序图或流程图

Markdown 语法：

	```sequence
	张三->李四: 嘿，小四儿, 写博客了没?
	Note right of 李四: 李四愣了一下，说：
	李四-->张三: 忙得吐血，哪有时间写。
	```

	```flow
	st=>start: 开始
	e=>end: 结束
	op=>operation: 我的操作
	cond=>condition: 确认？

	st->op->cond
	cond(yes)->e
	cond(no)->op
	```

效果如下（ `Preferences` - `Themes` - `Enable sequence & flow chart` 才会看到效果 ）：

```sequence
张三->李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四-->张三: 忙得吐血，哪有时间写。
```

```flow
st=>start: 开始
e=>end: 结束
op=>operation: 我的操作
cond=>condition: 确认？

st->op->cond
cond(yes)->e
cond(no)->op
```

更多请参考：<http://bramp.github.io/js-sequence-diagrams/>, <http://adrai.github.io/flowchart.js/>

## 表格

Markdown 语法：

```txt
第一格表头 | 第二格表头
--------- | -------------
内容单元格 第一列第一格 | 内容单元格第二列第一格
内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格
```

效果如下：

第一格表头 | 第二格表头
--------- | -------------
内容单元格 第一列第一格 | 内容单元格第二列第一格
内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格


## 删除线

Markdown 语法：

	加删除线像这样用： ~~删除这些~~

效果如下：

加删除线像这样用： ~~删除这些~~

## 分隔线

以下三种方式都可以生成分隔线：

	***

	*****

	- - -

效果如下：

***

*****

- - -



## MathJax

Markdown 语法：

```
块级公式：
$$	x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$

\\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \\]

行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$
```

效果如下（`Preferences` - `Themes` - `Enable MathJax` 才会看到效果）：

块级公式：
$$	x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$

\\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \\]


行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$


## 脚注（Footnote）

Markdown 语法：

```
这是一个脚注：[^sample_footnote]
```

效果如下：

这是一个脚注：[^sample_footnote]

[^sample_footnote]: 这里是脚注信息


## 注释和阅读更多

<!-- comment -->
<!-- more -->

Actions->Insert Read More Comment *或者* `Command + .`
**注** 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。

## TOC

Markdown 语法：

```
[TOC]
```

效果如下：

[TOC]





</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/swiftUI_blogs</guid><title>SwiftUI博客列表</title><description>SwiftUI不错的博客.</description><link>https://your-website-url.com/posts/swiftUI_blogs</link><pubDate>Wed, 1 Dec 2021 10:47:00 +0800</pubDate><content:encoded><![CDATA[<ol><li><a href="https://www.donnywals.com/understanding-how-and-when-swiftui-decides-to-redraw-views/">SwiftUI redraw Views</a></li><li><a href="https://jaywcjlove.gitee.io/swiftui-example/cheat-sheet.html">SwiftUI 速查手册</a></li><li><a href="https://github.com/jaywcjlove/swiftui-example">swiftUI example code</a></li><li><a href="https://jaywcjlove.gitee.io/swiftui-example/example/appendix-a/demo2/index.html">SwiftUI属性包装器</a></li><li><a href="https://jaywcjlove.gitee.io/swiftui-example/">swiftUI example docs</a></li><li><a href="https://swiftbysundell.com/">Swift actors</a></li></ol><p><a href="https://swiftbysundell.com/articles/">swiftbysundell</a></p>]]></content:encoded></item></channel></rss>